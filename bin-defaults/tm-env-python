#!/usr/bin/env bash
#
# Run python, auto installing it and setting up the env as required
#

set -Eeuo pipefail

source "$TM_BIN/.tm.boot.sh"

runner_args=()
script_path=""
script_cmd_args=()

# Find the index of the script path.
# This assumes the script path is the first argument that exists as a file and is executable,
# and is not the runner itself ($0). This is a common and robust heuristic.
script_index=-1
for i in $(seq 1 $#); do # Loop through 1-based argument indices
    arg="${!i}" # Get the argument value
    if [[ -f "$arg" && -x "$arg" && "$arg" != "$0" ]]; then
        script_index="$i"
        break
    fi
done

if [[ "$script_index" -eq -1 ]]; then
    _fail "Error: Could not determine the script path in tm-env-deno." >&2
fi

# Capture runner arguments (everything before the script path)
if [[ $((script_index - 1)) -ge 1 ]]; then
    for i in $(seq 1 $((script_index - 1))); do
        runner_args+=("${!i}")
    done
fi

# The script path itself
script_path="${!script_index}"
#script_path="$(_realpath "$script_path")"

_debug "Script Path: $script_path"

if [[ -z "$script_path" ]]; then
  _fail "Usage: tm-env-python <script_path> [args...]"
fi

if [[ ! -f "$script_path" ]]; then
  _fail "Error: Script not found at '$script_path'"
fi

# Capture arguments passed to the script on the command line (everything after the script path)
if [[ $((script_index + 1)) -le $# ]]; then
    script_cmd_args=("${@:$((script_index + 1))}")
fi

# todo: remove these
PIP_REQUIREMENTS=""
VENV_PROVIDER='python' # uv/python/none
PYTHON_VERSION='3.13'
VENV_TYPE='plugin'  #none/script/plugin
VENV_PATH=''

__provision_env(){
    local -n env_details="$1" #associative array
    local script_path="$2"

    env_details=() # clear the array

    local VENV_PROVIDER='python' # uv/python/none
    local PYTHON_VERSION='3.13'
    local VENV_TYPE='plugin'  #none/script/plugin
    local VENV_PATH=''

    #
    # We cache the results of the parse, and only regenerate an environment if changes detected. This makes
    # script invocation much faster

    # Get a hash of the file, only regenerate if things changed, or the env needs updating (e.g. removed)
    local current_checksum=$(stat -c %Y "$script_path" | md5sum | awk '{print $1}') # Hash concatenated mtimes. Probably good enough for now
    local path_hash=$(echo "$script_path" | md5sum | awk '{print $1}') # Consistent cache file name
    # a file that has cached our previous analysis of this file. It includes a checksum of the file we analysed, so that we can detect when
    # it needs regeneration
    # we want to do as little work as possible once we have a script env setup, so lazy load as much as we can
    local cache_file="$TM_CACHE_DIR/tm-env-python/script-${path_hash}.cache"
    if [[ -f "$cache_file" ]]; then
      # load from cache
      IFS=$'\t' read -r saved_checksum VENV_TYPE VENV_PROVIDER VENV_PATH< <(cat "$cache_file")

      _is_finest && _finest "cache_file '$cache_file', contents: $(cat "$cache_file")"
      _is_trace && _trace "VENV_TYPE='${VENV_TYPE}' VENV_PROVIDER='${VENV_PROVIDER}' VENV_PATH='${VENV_PATH}'"
    fi
    # analyse file if we have no cache, or the file checksum has changed
    if [[ ! -f "$cache_file" ]] || [[ "$current_checksum" != "${saved_checksum:-}" ]]; then
      # extract all the directives from the script
      local directives_file="${TM_CACHE_DIR}/tm-venv-scripts/script-${path_hash}.${__TM_VENV_REQUIRES_SUFFIX}.${current_checksum}"
      if [[ ! -f "$directives_file" ]]; then
         _source_once "$TM_BIN/.tm.venv.directives.sh"
        _tm::venv::extract_directives "${script_path}" "${directives_file}"
      fi
      _is_finest && _finest "directives_file '$directives_file', contents: $(cat "$directives_file")"
      _is_trace && _trace "VENV_TYPE='${VENV_TYPE}' VENV_PROVIDER='${VENV_PROVIDER}' VENV_PATH='${VENV_PATH}'"

      # Use mapfile (or readarray) to read lines into an array
      # -t option removes the trailing newline character from each line
      mapfile -t directives < "$directives_file"
      PIP_REQUIREMENTS=''
      for directive in "${directives[@]}"; do
        echo "directive: '$directive'" # Using quotes around $line is crucial to preserve spaces
        # Perform actions with "$line" here
        if [[ -n "${directive}" ]]; then
              _debug "  - '${directive}'" # Log the full directive
              if [[ "${directive}" == "pip:"* ]]; then
                # Extract the package spec after "pip:"
                pip_package="${directive#pip:}"
                # Add to PIP_REQUIREMENTS, ensuring newline separation if not empty
                if [[ -z "$PIP_REQUIREMENTS" ]]; then
                  PIP_REQUIREMENTS="$pip_package"
                else
                  PIP_REQUIREMENTS="$PIP_REQUIREMENTS"$'\n'"$pip_package"
                fi
              elif [[ "${directive}" == "python:"* ]]; then
                #_debug "    (Note: Python version directive '${req_line#python:}' captured)"
                PYTHON_VERSION="${directive#python:}"
              elif [[ "${directive}" == "venv:provider:"* ]]; then
                VENV_PROVIDER="${directive#venv:provider:}"
              elif [[ "${directive}" == "venv:"* ]]; then
                VENV_TYPE="${directive#venv:}"
              else
                : #_debug "    (Note: Non-pip/non-python directive captured: $req_line)"
              fi
          fi
      done
      if [[ "$VENV_TYPE" != "none" ]]; then
        _debug "PIP_REQUIREMENTS=$PIP_REQUIREMENTS"

        # list requirements if any
        if [[ -n "$PIP_REQUIREMENTS" ]]; then
          _debug "Script require directives detected. Requires dependencies:"
          # Print each requirement before attempting to install all
          echo "$PIP_REQUIREMENTS" | while IFS= read -r req_line; do
            if [[ -n "$req_line" ]]; then
                _debug "  - $req_line"
            fi
          done
        fi
        VENV_PATH="$(__get_venv_dir "$script_path" "$VENV_TYPE")"
      fi
      mkdir -p "$(dirname "$cache_file")"
      echo -e "$current_checksum\t$VENV_TYPE\t$VENV_PROVIDER\t$VENV_PATH" > "$cache_file"
    fi

    env_details[venv_type]="$VENV_TYPE"
    env_details[venv_path]="$VENV_PATH"
    env_details[venv_provider]="$VENV_PROVIDER"
    env_details[pip_requirements]="$PIP_REQUIREMENTS"
}
__invoke_env(){
    local -n env_details="$1" #associative array
    local script_path="$2"

}
_main(){
  local -A env
  __provision_env env "$script_path"
  #__invoke_env  env "$script_path" # todo: figure this one out

  local venv_type="${env[venv_type]}"
  local venv_path="${env[venv_path]}"
  local venv_provider="${env[venv_provider]}"
  local pip_requirements="${env[pip_requirements]}"

  if [[ "$venv_type" == "none" ]]; then
      # run directly
      _python3 "$script_path" "${script_cmd_args[@]}"
  else
    _source_once "$TM_BIN/.tm.venv.provision.sh"

    _debug "Target venv path: $venv_path"
    # Ensure the parent directory for the venv exists
    mkdir -p "$(dirname "$venv_path")"
    if [[ "$venv_provider" == 'uv' ]]; then
      __invoke_in_uv_env "$venv_path" uv run --no-project "${script_path}" "${script_cmd_args[@]}"
    elif [[ "$venv_provider" == "python" ]]; then
      __invoke_in_python_venv "$venv_path" python "${script_path}" "${script_cmd_args[@]}"
    else
      _fail "unknown venv_provider '$venv_provider'"
    fi
  fi
}

__get_venv_dir(){
  local script="$1"
  local venv_type="${2:-}"

  __extract_plugin_name(){
    local script_path="$1"
    local dir="$2"
    _trace "args: $*"
    
    local remove_prefix="$dir/"
    local script_rel_path="${script_path#$remove_prefix}"
    local plugin_dir_name="${script_rel_path%%/*}"
    local -A plugin=()
    _tm::util::parse::plugin_name plugin "$plugin_dir_name"
    echo -n "$TM_PLUGINS_VENV_DIR/plugin-${plugin['key']}"
  }

  if [[ "$venv_type" == 'script'  ]]; then
    echo -n "$TM_PLUGINS_VENV_DIR/script-$(echo -n "$script" | base64 | md5sum | cut -d ' ' -f1)"
  elif [[ "$script" == "$TM_HOME/"* ]]; then
    echo -n "$TM_PLUGINS_VENV_DIR/tool-manager"
  elif [[ -n "$TM_PLUGINS_INSTALL_DIR" && "$script" == "$TM_PLUGINS_INSTALL_DIR/"* ]]; then
    __extract_plugin_name "$script" "$TM_PLUGINS_INSTALL_DIR"
  elif [[ -n "$TM_PLUGINS_ENABLED_DIR" && "$script" == "$TM_PLUGINS_ENABLED_DIR/"* ]]; then
    __extract_plugin_name "$script" "$TM_PLUGINS_ENABLED_DIR"
  else
    # per script venv atm, to improve isolation
    echo -n "$TM_PLUGINS_VENV_DIR/script-$(echo -n "$script" | base64 | md5sum | cut -d ' ' -f1)"
  fi
}


__invoke_in_uv_env(){
  local venv_path="$1"
  shift
  # Create/update the virtual environment using uv
  _fail_if_not_installed uv 'Please install uv (https://github.com/astral-sh/uv)"'

  _debug "Ensuring venv exists at $venv_path..."
  if ! uv venv --quiet "$venv_path"; then
      _fail "Error: Failed to create or validate venv at $venv_path using uv."
  fi
  if [[ -n "$PIP_REQUIREMENTS" ]]; then
    _debug "Installing dependencies:"
    # Install all requirements at once using uv, targeting the venv's Python
    local python_in_venv="$venv_path/bin/python"
    if [[ ! -x "$python_in_venv" ]]; then
      _error "Error: Python executable not found or not executable in venv: $python_in_venv"
      _warn "Warning: Skipping dependency installation."
    elif ! echo "$PIP_REQUIREMENTS" | uv pip install --quiet --python "$python_in_venv" -r /dev/stdin; then
      _warn "Warning: Failed to install some/all dependencies into $venv_path using 'uv pip install --python ...'."
      # Decide if this should be a fatal error. For now, a warning.
    else
      _debug "Dependencies installed/updated successfully."
    fi
  else
    _debug "No 'require:' lines found in script header. Skipping dependency installation."
  fi

  # Stage 5: Invoke script using the venv's Python
  _debug "Invoking script with venv Python..."
  # activate env
  source "$venv_path/bin/activate"
  # finally run it
  "$@"
}

__invoke_in_python_venv(){
  local venv_path="$1"
  shift

  _debug "invoking via python venv ($venv_path)"


  if [[ ! -f "$venv_path/bin/activate" ]]; then
    _debug "no venv, creating '$venv_path'"
    python3 -m venv "$venv_path" 
    source "$venv_path/bin/activate"
    # python3 -m pip install --upgrade pip
    # python3 -m pip --version
    whereis python
    _debug "ensuring pip installed"
    python -m ensurepip --upgrade
    #python pip install --upgrade pip
    python -m pip --version
  else
    source "$venv_path/bin/activate"
  fi
  if [[ -n "$PIP_REQUIREMENTS" ]]; then
    _debug "Installing pip dependencies:"
    # Install all requirements at once using uv, targeting the venv's Python
    if ! echo "$PIP_REQUIREMENTS" | python -m pip install -r /dev/stdin; then
      _warn "Warning: Failed to install some/all dependencies into $venv_path using 'python3 -m pip install ...'."
      # Decide if this should be a fatal error. For now, a warning.
    else
      _debug "Dependencies installed/updated successfully."
    fi
  fi
  _debug "invoking python script '$script_path'"
 "$@"
}


_main "$@"